/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  v2106                                 |
|   \\  /    A nd           | Website:  www.openfoam.com                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      controlDict;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

// application     interFoam;
// application     interIsoFoam;
application     interIsoDeboRheoFoam;

startFrom       latestTime;

startTime       0;

stopAt          endTime;

endTime         26.50;

deltaT          0.00001;

writeControl    adjustableRunTime;

writeInterval   0.50;

purgeWrite      0;

writeFormat     binary;

writePrecision  6;

writeCompression off;

timeFormat      general;

timePrecision   6;

runTimeModifiable yes;

adjustTimeStep  yes;

// maxCo           0.45;
//
// maxAlphaCo      0.45;

maxCo           0.4825;

maxAlphaCo      0.4825;

maxDeltaT       0.05;

maxCapillaryNum 2000.0; //mu*V/sigma

libs (
    //    "libsimpleFunctionObjects.so"
        // "libsimpleSwakFunctionObjects.so"
        "libswakFunctionObjects.so"
        "libgroovyBC.so"
        "libOpenFOAM.so"
//         "libforces.so"
        // "libBCRheoTool.so"
    );

functions
{
        outputForce
    {
	 functionObjectLibs ("libutilityFunctionObjects.so");
	 type coded;
	 name calCd;
	 writeControl timeStep;
        writeInterval      25;
        enabled             yes;

	 codeWrite
	 #{
          // Lookup/create variable

        const volVectorField& U = mesh().lookupObject<volVectorField>("U");
        const volSymmTensorField& tau = mesh().lookupObject<volSymmTensorField>("tau");
        // const volSymmTensorField& tau = mesh().lookupObject<volSymmTensorField>("tau.water");
        const volScalarField& p = mesh().lookupObject<volScalarField>("p");
        const dictionary& constDict = mesh().lookupObject<IOdictionary>("transportProperties");
        const volScalarField& alphaWater = mesh().lookupObject<volScalarField>("alpha.water");
        dimensionedScalar rho_(constDict.subDict("water").subDict("rheology").lookup("rho"));
        dimensionedScalar etaS_(constDict.subDict("water").subDict("rheology").subDict("solventViscosity").subDict("constantEtaCoeffs").lookup("eta"));
        dimensionedScalar etaP_(constDict.subDict("water").subDict("rheology").subDict("polymerProperties").subDict("constantEtaCoeffs").lookup("eta"));

           label cyl = mesh().boundaryMesh().findPatchID("Cylinder");
           scalarList list;

          // Compute cd

           volTensorField L(fvc::grad(U));

	//    volSymmTensorField F(tau + symm( L + L.T() ) * etaS_ * alphaWater- p * symmTensor::I * rho_* alphaWater);
        //    volSymmTensorField F(tau + symm( L + L.T() ) * etaS_- p * symmTensor::I * rho_);
        // volSymmTensorField F(tau + symm( L + L.T() ) * etaS_- p * symmTensor::I );
        volSymmTensorField F(tau + symm( L + L.T() ) * etaS_ * alphaWater + p * symmTensor::I * alphaWater );
        volSymmTensorField FPloy( tau + symm( L + L.T() ) * etaS_ * alphaWater );
        volSymmTensorField FVS( symm( L + L.T() ) * etaS_ * alphaWater );
        volSymmTensorField FElastic( tau * alphaWater );
        volSymmTensorField FPressure( p * symmTensor::I * alphaWater );

        //    vector Fpatch = gSum( ( -mesh().boundaryMesh()[cyl].faceAreas() ) & F.boundaryField()[cyl] )/(etaS_ + etaP_).value();
        vector Fpatch = gSum( ( -mesh().boundaryMesh()[cyl].faceAreas() ) & F.boundaryField()[cyl] );
        vector FpatchPoly = gSum( ( -mesh().boundaryMesh()[cyl].faceAreas() ) & FPloy.boundaryField()[cyl] );
        vector FpatchPressure = gSum( ( -mesh().boundaryMesh()[cyl].faceAreas() ) & FPressure.boundaryField()[cyl] );
        vector FFVS = gSum( ( -mesh().boundaryMesh()[cyl].faceAreas() ) & FVS.boundaryField()[cyl] );
        vector FFElastic = gSum( ( -mesh().boundaryMesh()[cyl].faceAreas() ) & FElastic.boundaryField()[cyl] );

            list.append(mesh().time().value());  // Time (col 0)
            list.append(FpatchPoly.x());             // Cd   (col 1)
            list.append(FpatchPressure.x());             // Cd   (col 2)
            list.append(FFVS.x());             // Cd   (col 1)
            list.append(FFElastic.x());             // Cd   (col 2)
            list.append(Fpatch.x());             // Cd   (col 3)

          // Write data
           string comsh;
           string filename("Force.txt");
	   std::stringstream doub2str; doub2str.precision(12);

           comsh = "./writeData " + filename;
           forAll(list, id)
            {
              doub2str.str(std::string());
              doub2str << list[id];
              comsh += " " + doub2str.str();
            }

           if (Pstream::master())
            {
	      system(comsh);
            }
	 #};
    }

    outputViscousStress
    {
	 functionObjectLibs ("libutilityFunctionObjects.so");
	 type coded;
//         type            codeStream;
//         libs            (fieldFunctionObjects); // Required to use field-related functions
//          functionObjectLibs ("fieldFunctionObjects.so");
	 name writeVS;
	 writeControl adjustableRunTime;
     writeInterval      0.5;
     enabled             yes;
     
     codeInclude
        #{
            #include "fvCFD.H"
            #include "IOstreams.H"
            #include "volFields.H"
        #};

//         codeOptions
//         #{
//             -I$(FOAM_SRC)/finiteVolume/lnInclude
//             -I$(FOAM_SRC)/meshTools/lnInclude
//         #};
// 
//         codeLibs
//         #{
//             -lmeshTools
//             -lfiniteVolume
//         #};
        
	 codeWrite
        #{
            const volVectorField& U = mesh().lookupObject<volVectorField>("U");
            volTensorField L(fvc::grad(U));
            const dictionary& constDict = mesh().lookupObject<IOdictionary>("transportProperties");
            dimensionedScalar etaS_(constDict.subDict("water").subDict("rheology").subDict("solventViscosity").subDict("constantEtaCoeffs").lookup("eta"));
//             volSymmTensorField ViscousStress = ( symm( L + L.T() ) * etaS_  );
            volSymmTensorField ViscousStressField
            (
                IOobject
                (
                    "ViscousStress",         // Name of the new field
                    mesh().time().timeName(),
                    U.mesh(),
                    IOobject::NO_READ,
                    IOobject::AUTO_WRITE
                ),
                symm( L + L.T() ) * etaS_ 
            );
            ViscousStressField.write();
        #};
    }
}

// ************************************************************************* //
